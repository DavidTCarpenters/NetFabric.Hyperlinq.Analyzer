# HLQ001: Assigment causes boxing of enumerator

## Cause

An enumerable or async enumerable, that uses value type enumerators, is assigned to a non-public variable, field or property whose type causes the enumerator to be boxed.

## Severity

Warning

## Rule description

Enumerables and async enumerables can be implemented so that they use value type enumerators. The advantage is that calls to its methods are not virtual and the enumerator is allocated in the stack.

Most collections in the .NET framework are implemented this way. Here's an excerpt of the implementation of `System.Collections.Generic.List<T>` :

```csharp
public class List<T> : IList<T>, IList, IReadOnlyList<T>
{
    public Enumerator GetEnumerator()
        => new Enumerator(this);

    IEnumerator<T> IEnumerable<T>.GetEnumerator()
        => new Enumerator(this);

    IEnumerator IEnumerable.GetEnumerator()
        => new Enumerator(this);
        
    public struct Enumerator : IEnumerator<T>, IEnumerator
    {
        public bool MoveNext()
        {
            ...
        }
            
        public T Current => _current;

        object IEnumerator.Current
        {
            get
            {
                ...
            }
        }       
    }
}
```

Notice that the public `GetEnumerator()` method returns the inner type `Enumerator` which is implemented as a `struct`. The other two overloads are implemented explicitly so that they are called when the `List<T>` is cast to one of these interfaces.

The C# `foreach` is implemented so that the public `GetEnumerator()` can be called. For example:

```csharp
var list = new List<int>();
foreach (var item in list)
    Console.WriteLine(item);
```

The compiler interprets it as the following:

```csharp
List<int> list = new List<int>();
List<int>.Enumerator enumerator = list.GetEnumerator();
try
{
    while (enumerator.MoveNext())
    {
        int current = enumerator.Current;
        Console.WriteLine(current);
    }
}
finally
{
    ((IDisposable)enumerator).Dispose();
}
```

The `list` variable is declared as type `List<int>` and the `enumerator` variable as type `List<int>.Enumerator`.

Changing the type of the `list` variable to any of the interfaces implemented by `List<T>`

```csharp
IReadOnlyList<int> list = new List<int>();
foreach (var item in list)
    Console.WriteLine(item);
```

results in the `GetEnumerator()` overload that is called now to be one implemented explicitly, which returns an interface. `foreach` is then expanded accordingly with the type of the `enumerator` variable now being `IEnumerator<int>` :

```csharp
IReadOnlyList<int> readOnlyList = new List<int>();
IEnumerator<int> enumerator = readOnlyList.GetEnumerator();
try
{
    while (enumerator.MoveNext())
    {
        int current = enumerator.Current;
        Console.WriteLine(current);
    }
}
finally
{
    if (enumerator != null)
    {
        enumerator.Dispose();
    }
}
```

This causes the `Enumerator` instance to be copied to the heap and all calls to its `MoveNext()` method and `Current` property to be virtual, reducing performance.

The [state machine generated by `await foreach`](https://sharplab.io/#v2:CYLg1APgAgTAjAWAFBQAwAIpwCwG5lqZwB0AKgBYBOApgIbACWAdgOb4oZYCs7BAzJhjoAwumQBvZOmmYBWAGyYAHOgBqtADYBXalEUBZagBdyAe2ABBAM4BPJgGMAFAEoxSGeknuPMgG61KdGomLQBbakpaACMNanQAXnQmagB3dAB5AAcjBlCGAC9qS1sHAFEQ8MiY6gAeZiMAPhd2HxkoAE50ADNTGlp7ckd/QIYjalD0ZiCKiOjY52QASEWvZcWsdsdR8ed2ZYBfKRlDpBOCISycvMLiu3tysNnqmtIG9BB0AElrO4fKudqrwkR2kUAEf1mRl66AA4sYfmUZpEoZRHMJaA5qBoNLQcqYmKRTABrYLoewY+xYnF4gnE0mJYDULq0LQaIwLbyteJvZJpCHI3rNEFfBH3JG43ovN7fEpix5VWJS4hwoyi/kS1HozHY3EMfGEklMMkUqm6/V0pgc1rSblJVLodUooVIYVg9BWIyULT2IwO8Uo94i2WOyVAzmeYUeN2kERaSg0Ji+22M5msoy8cNRgTqbS6eQ1KKmUwaN76Uy+agAOWoAA9VbKXAkefaczo9AWiyXHMyNFZqLtkJG2tnNG3FAARBhWTKmPuixu23lqUd550eE4nIA) performs exactly the same behavior when using async enumerables with value-typed enumerators.

## How to fix violations

Change the type of the variable, field or property so that boxing is avoided. Using `var`, instead of the explicit type, guarantees that the correct type is always used.

## When to suppress warnings

Optionally, when `foreach` is not used to enumerate the collection.

## Example of a violation

The following example shows the multiples cases of assignment that are detected by this rule:

```csharp
class Class1
{
    IList<int> privateField = new List<int>();
    IAsyncEnumerable<int> privateAsyncField = new OptimizedAsyncEnumerable();

    IList<int> PrivateProperty { get; set; } = new List<int>();
    IAsyncEnumerable<int> PrivateAsyncProperty { get; set; } 
    	= new OptimizedAsyncEnumerable();

    void Method()
    {
        IList<int> localVariable = new List<int>();
        IAsyncEnumerable<int> localAsyncVariable = new OptimizedAsyncEnumerable();

        privateField = new List<int>();
        PrivateProperty = new List<int>();
        localVariable = new List<int>();
        privateAsyncField = new OptimizedAsyncEnumerable();
        PrivateAsyncProperty = new OptimizedAsyncEnumerable();
        localAsyncVariable = new OptimizedAsyncEnumerable();
    }
}
```

## Example of how to fix

Changing the types `List<int>` or using `var` for the local variable declaration, solves the issue:

```csharp
class Class1
{
    List<int> privateField = new List<int>();
    OptimizedAsyncEnumerable privateAsyncField = new OptimizedAsyncEnumerable();

    List<int> PrivateProperty { get; set; } = new List<int>();
    OptimizedAsyncEnumerable PrivateAsyncProperty { get; set; } 
    	= new OptimizedAsyncEnumerable();

    void Method()
    {
        var localVariable = new List<int>();
        var localAsyncVariable = new OptimizedAsyncEnumerable();

        privateField = new List<int>();
        PrivateProperty = new List<int>();
        localVariable = new List<int>();
        privateAsyncField = new OptimizedAsyncEnumerable();
        PrivateAsyncProperty = new OptimizedAsyncEnumerable();
        localAsyncVariable = new OptimizedAsyncEnumerable();
    }
}
```
